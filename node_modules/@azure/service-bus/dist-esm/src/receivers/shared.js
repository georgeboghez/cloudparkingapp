// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncGenerator, __await, __awaiter } from "tslib";
import { receiverLogger } from "../log";
import { translateServiceBusError } from "../serviceBusError";
import { DispositionType } from "../serviceBusMessage";
import { ErrorNameConditionMapper } from "@azure/core-amqp";
import { MessageAlreadySettled } from "../util/errors";
import { isDefined } from "../util/typeGuards";
/**
 * @internal
 */
export function assertValidMessageHandlers(handlers) {
    if (handlers &&
        handlers.processMessage instanceof Function &&
        handlers.processError instanceof Function) {
        return;
    }
    throw new TypeError('Invalid "MessageHandlers" provided.');
}
/**
 * @internal
 */
export function getMessageIterator(receiver, options) {
    return __asyncGenerator(this, arguments, function* getMessageIterator_1() {
        while (true) {
            const messages = yield __await(receiver.receiveMessages(1, options));
            if (messages.length === 0) {
                continue;
            }
            yield yield __await(messages[0]);
        }
    });
}
/**
 * @internal
 */
export function wrapProcessErrorHandler(handlers, logger = receiverLogger) {
    return (args) => __awaiter(this, void 0, void 0, function* () {
        try {
            args.error = translateServiceBusError(args.error);
            yield handlers.processError(args);
        }
        catch (err) {
            logger.logError(err, `An error was thrown from the user's processError handler`);
        }
    });
}
/**
 * @internal
 *
 */
export function completeMessage(message, context, entityPath) {
    receiverLogger.verbose("[%s] Completing the message with id '%s'.", context.connectionId, message.messageId);
    return settleMessage(message, DispositionType.complete, context, entityPath);
}
/**
 * @internal
 *
 */
export function abandonMessage(message, context, entityPath, propertiesToModify) {
    receiverLogger.verbose("[%s] Abandoning the message with id '%s'.", context.connectionId, message.messageId);
    return settleMessage(message, DispositionType.abandon, context, entityPath, {
        propertiesToModify
    });
}
/**
 * @internal
 *
 */
export function deferMessage(message, context, entityPath, propertiesToModify) {
    receiverLogger.verbose("[%s] Deferring the message with id '%s'.", context.connectionId, message.messageId);
    return settleMessage(message, DispositionType.defer, context, entityPath, {
        propertiesToModify
    });
}
/**
 * @internal
 *
 */
export function deadLetterMessage(message, context, entityPath, propertiesToModify) {
    receiverLogger.verbose("[%s] Deadlettering the message with id '%s'.", context.connectionId, message.messageId);
    const actualPropertiesToModify = Object.assign({}, propertiesToModify);
    // these two fields are handled specially and don't need to be in here.
    delete actualPropertiesToModify.deadLetterErrorDescription;
    delete actualPropertiesToModify.deadLetterReason;
    const dispositionStatusOptions = {
        propertiesToModify: actualPropertiesToModify,
        deadLetterReason: propertiesToModify === null || propertiesToModify === void 0 ? void 0 : propertiesToModify.deadLetterReason,
        deadLetterDescription: propertiesToModify === null || propertiesToModify === void 0 ? void 0 : propertiesToModify.deadLetterErrorDescription
    };
    return settleMessage(message, DispositionType.deadletter, context, entityPath, dispositionStatusOptions);
}
/**
 * @internal
 *
 */
function settleMessage(message, operation, context, entityPath, options) {
    const isDeferredMessage = !message.delivery.link;
    const receiver = isDeferredMessage
        ? undefined
        : context.getReceiverFromCache(message.delivery.link.name, message.sessionId);
    const associatedLinkName = receiver === null || receiver === void 0 ? void 0 : receiver.name;
    let error;
    if (message.delivery.remote_settled) {
        error = new Error(MessageAlreadySettled);
    }
    else if (!isDeferredMessage &&
        (!receiver || !receiver.isOpen()) &&
        isDefined(message.sessionId)) {
        error = translateServiceBusError({
            description: `Failed to ${operation} the message as the AMQP link with which the message was ` +
                `received is no longer alive.`,
            condition: ErrorNameConditionMapper.SessionLockLostError
        });
    }
    if (error) {
        receiverLogger.logError(error, "[%s] An error occurred when settling a message with id '%s'", context.connectionId, message.messageId);
        throw error;
    }
    // Message Settlement with managementLink
    // 1. If the received message is deferred as such messages can only be settled using managementLink
    // 2. If the associated receiver link is not available. This does not apply to messages from sessions as we need a lock on the session to do so.
    if (isDeferredMessage || ((!receiver || !receiver.isOpen()) && !isDefined(message.sessionId))) {
        return context
            .getManagementClient(entityPath)
            .updateDispositionStatus(message.lockToken, operation, Object.assign(Object.assign({}, options), { associatedLinkName, sessionId: message.sessionId }))
            .catch((err) => {
            throw translateServiceBusError(err);
        });
    }
    return receiver.settleMessage(message, operation, options).catch((err) => {
        throw translateServiceBusError(err);
    });
}
//# sourceMappingURL=shared.js.map